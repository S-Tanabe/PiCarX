<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>VR Stereo Viewer (LiveKit + WebXR)</title>
    <style>
      * { margin: 0; padding: 0; }
      body {
        background: #000;
        color: #fff;
        font-family: system-ui, sans-serif;
        overflow: hidden;
      }
      #ui {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 100;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      button {
        padding: 15px 30px;
        font-size: 18px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        background: #4a90d9;
        color: #fff;
      }
      button:hover { background: #3a7bc8; }
      button:disabled { background: #555; cursor: not-allowed; }
      #status {
        padding: 10px;
        background: rgba(0,0,0,0.7);
        border-radius: 8px;
      }
      #preview {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 320px;
        background: #111;
        border: 1px solid #333;
        border-radius: 8px;
      }
      #canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <button id="connectBtn">Connect to LiveKit</button>
      <button id="vrBtn" disabled>Enter VR</button>
      <button id="previewBtn" disabled>Preview Stereo (Non-VR)</button>
      <div id="status">Status: Disconnected</div>
    </div>
    <video id="preview" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>

    <!-- LiveKit SDK -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/livekit-client/2.15.7/livekit-client.umd.js"></script>

    <!-- Three.js for WebXR -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
      // ====== 設定 ======
      const wsUrl = 'wss://relay.yuru-yuru.net';
      const token = 'eyJhbGciOiJIUzI1NiJ9.eyJ2aWRlbyI6eyJyb29tSm9pbiI6dHJ1ZSwicm9vbSI6InZyLWRlbW8iLCJjYW5TdWJzY3JpYmUiOnRydWUsImNhblB1Ymxpc2giOmZhbHNlLCJjYW5QdWJsaXNoRGF0YSI6ZmFsc2V9LCJpc3MiOiJMS19BUElfS0VZIiwiZXhwIjoxNzY2MDk2NTQ1LCJuYmYiOjAsInN1YiI6InZpZXdlci0zZDh2OTMifQ.epdrv0CftHMpIvBRdSH4gs4PuARYcA9NlqQ7Bh8uyHU';
      // ==================

      const connectBtn = document.getElementById('connectBtn');
      const vrBtn = document.getElementById('vrBtn');
      const previewBtn = document.getElementById('previewBtn');
      const statusEl = document.getElementById('status');
      const preview = document.getElementById('preview');
      const canvas = document.getElementById('canvas');

      let room = null;
      let videoElement = null;
      let renderer, scene, cameraL, cameraR, camera;
      let xrSession = null;
      let videoTexture = null;
      let previewMode = false;

      function setStatus(msg) {
        statusEl.textContent = 'Status: ' + msg;
        console.log(msg);
      }

      // LiveKit接続
      async function connectLiveKit() {
        setStatus('Connecting...');
        connectBtn.disabled = true;

        try {
          room = new LivekitClient.Room({
            adaptiveStream: true,
            dynacast: true,
          });

          room.on(LivekitClient.RoomEvent.TrackSubscribed, (track, pub, participant) => {
            if (track.kind === 'video') {
              setStatus('Video track received');
              videoElement = track.attach();
              videoElement.style.display = 'none';
              document.body.appendChild(videoElement);

              // プレビュー表示
              const previewEl = track.attach();
              preview.srcObject = previewEl.srcObject;

              // WebXR用テクスチャ更新
              if (videoTexture) {
                videoTexture.image = videoElement;
              }

              vrBtn.disabled = false;
              previewBtn.disabled = false;
            }
          });

          room.on(LivekitClient.RoomEvent.Disconnected, () => {
            setStatus('Disconnected');
            vrBtn.disabled = true;
            previewBtn.disabled = true;
            connectBtn.disabled = false;
          });

          await room.connect(wsUrl, token);
          setStatus('Connected to room: ' + room.name);

          // 既存の参加者のトラックを購読
          room.remoteParticipants.forEach(p => {
            p.trackPublications.forEach(pub => {
              if (pub.isSubscribed && pub.track && pub.track.kind === 'video') {
                videoElement = pub.track.attach();
                videoElement.style.display = 'none';
                document.body.appendChild(videoElement);

                const previewEl = pub.track.attach();
                preview.srcObject = previewEl.srcObject;

                vrBtn.disabled = false;
                previewBtn.disabled = false;
              }
            });
          });

        } catch (e) {
          setStatus('Connection failed: ' + e.message);
          connectBtn.disabled = false;
        }
      }

      // Three.js + WebXR セットアップ
      function initThreeJS() {
        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // ステレオカメラ（左右）
        cameraL = new THREE.PerspectiveCamera(75, 0.5, 0.1, 1000);
        cameraR = new THREE.PerspectiveCamera(75, 0.5, 0.1, 1000);
      }

      // VRモード開始
      async function enterVR() {
        if (!navigator.xr) {
          alert('WebXR is not supported on this device');
          return;
        }

        const supported = await navigator.xr.isSessionSupported('immersive-vr');
        if (!supported) {
          alert('Immersive VR is not supported');
          return;
        }

        try {
          xrSession = await navigator.xr.requestSession('immersive-vr', {
            optionalFeatures: ['local-floor', 'bounded-floor']
          });

          await renderer.xr.setSession(xrSession);
          setStatus('VR Mode Active');

          // ステレオビデオ用のジオメトリとマテリアル作成
          createStereoVideoMesh();

          // レンダリングループ開始
          renderer.setAnimationLoop(renderVR);

          xrSession.addEventListener('end', () => {
            setStatus('VR Mode Ended');
            renderer.setAnimationLoop(null);
            xrSession = null;
          });

        } catch (e) {
          setStatus('Failed to enter VR: ' + e.message);
        }
      }

      // ステレオビデオメッシュ作成
      function createStereoVideoMesh() {
        if (!videoElement) return;

        // ビデオテクスチャ
        videoTexture = new THREE.VideoTexture(videoElement);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;

        // 球体ジオメトリ（内側から見る）
        const radius = 5;
        const geometry = new THREE.SphereGeometry(radius, 64, 32);
        geometry.scale(-1, 1, 1); // 内側を向ける

        // 左目用マテリアル（テクスチャの左半分）
        const materialL = new THREE.ShaderMaterial({
          uniforms: {
            map: { value: videoTexture }
          },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D map;
            varying vec2 vUv;
            void main() {
              // 左半分のみ使用 (0.0 ~ 0.5)
              vec2 uv = vec2(vUv.x * 0.5, vUv.y);
              gl_FragColor = texture2D(map, uv);
            }
          `,
          side: THREE.BackSide
        });

        // 右目用マテリアル（テクスチャの右半分）
        const materialR = new THREE.ShaderMaterial({
          uniforms: {
            map: { value: videoTexture }
          },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D map;
            varying vec2 vUv;
            void main() {
              // 右半分のみ使用 (0.5 ~ 1.0)
              vec2 uv = vec2(0.5 + vUv.x * 0.5, vUv.y);
              gl_FragColor = texture2D(map, uv);
            }
          `,
          side: THREE.BackSide
        });

        // 左目用メッシュ（レイヤー1）
        const meshL = new THREE.Mesh(geometry.clone(), materialL);
        meshL.layers.set(1);
        scene.add(meshL);

        // 右目用メッシュ（レイヤー2）
        const meshR = new THREE.Mesh(geometry.clone(), materialR);
        meshR.layers.set(2);
        scene.add(meshR);
      }

      // VRレンダリングループ
      function renderVR(timestamp, frame) {
        if (!frame) return;

        const session = renderer.xr.getSession();
        const pose = frame.getViewerPose(renderer.xr.getReferenceSpace());

        if (pose) {
          const glLayer = session.renderState.baseLayer;
          const gl = renderer.getContext();

          gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);

          for (const view of pose.views) {
            const viewport = glLayer.getViewport(view);
            gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

            const camera = view.eye === 'left' ? cameraL : cameraR;
            camera.matrix.fromArray(view.transform.matrix);
            camera.projectionMatrix.fromArray(view.projectionMatrix);
            camera.matrixWorldNeedsUpdate = true;

            // 対応するレイヤーのみ表示
            camera.layers.enable(view.eye === 'left' ? 1 : 2);
            camera.layers.disable(view.eye === 'left' ? 2 : 1);

            renderer.render(scene, camera);
          }
        }

        // ビデオテクスチャ更新
        if (videoTexture) {
          videoTexture.needsUpdate = true;
        }
      }

      // 非VRプレビューモード（PCブラウザ用）
      function startPreview() {
        if (!videoElement) return;

        previewMode = true;
        setStatus('Preview Mode (Non-VR)');
        preview.style.display = 'none';

        // ビデオテクスチャ
        videoTexture = new THREE.VideoTexture(videoElement);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;

        // 左右に分割表示するための平面
        const aspect = window.innerWidth / window.innerHeight;
        camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
        camera.position.z = 2;

        // 左目用平面
        const planeGeomL = new THREE.PlaneGeometry(1, 1);
        const materialL = new THREE.ShaderMaterial({
          uniforms: { map: { value: videoTexture } },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D map;
            varying vec2 vUv;
            void main() {
              vec2 uv = vec2(vUv.x * 0.5, vUv.y);
              gl_FragColor = texture2D(map, uv);
            }
          `
        });
        const meshL = new THREE.Mesh(planeGeomL, materialL);
        meshL.position.x = -0.55;
        scene.add(meshL);

        // 右目用平面
        const planeGeomR = new THREE.PlaneGeometry(1, 1);
        const materialR = new THREE.ShaderMaterial({
          uniforms: { map: { value: videoTexture } },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D map;
            varying vec2 vUv;
            void main() {
              vec2 uv = vec2(0.5 + vUv.x * 0.5, vUv.y);
              gl_FragColor = texture2D(map, uv);
            }
          `
        });
        const meshR = new THREE.Mesh(planeGeomR, materialR);
        meshR.position.x = 0.55;
        scene.add(meshR);

        // レンダリングループ
        function animate() {
          if (!previewMode) return;
          requestAnimationFrame(animate);
          if (videoTexture) videoTexture.needsUpdate = true;
          renderer.render(scene, camera);
        }
        animate();

        previewBtn.disabled = true;
      }

      // イベントリスナー
      connectBtn.addEventListener('click', connectLiveKit);
      vrBtn.addEventListener('click', enterVR);
      previewBtn.addEventListener('click', startPreview);

      // 初期化
      initThreeJS();

      // リサイズ対応
      window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
