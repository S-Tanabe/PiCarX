<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>VR Stereo Viewer + Controller (LiveKit + WebXR + MQTT)</title>
    <style>
      * { margin: 0; padding: 0; }
      body {
        background: #000;
        color: #fff;
        font-family: system-ui, sans-serif;
        overflow: hidden;
      }
      #ui {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 100;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      button {
        padding: 15px 30px;
        font-size: 18px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        background: #4a90d9;
        color: #fff;
      }
      button:hover { background: #3a7bc8; }
      button:disabled { background: #555; cursor: not-allowed; }
      #status {
        padding: 10px;
        background: rgba(0,0,0,0.7);
        border-radius: 8px;
        font-size: 14px;
      }
      #preview {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 320px;
        background: #111;
        border: 1px solid #333;
        border-radius: 8px;
      }
      #canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
      .config {
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 8px;
        font-size: 14px;
      }
      .config input {
        background: #222;
        border: 1px solid #444;
        color: #fff;
        padding: 5px 8px;
        border-radius: 4px;
        width: 200px;
      }
      .config label {
        display: block;
        margin: 5px 0;
      }
      #controlInfo {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background: rgba(0,0,0,0.8);
        padding: 10px;
        border-radius: 8px;
        font-size: 12px;
        max-width: 300px;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <button id="connectBtn">Connect (LiveKit + MQTT)</button>
      <button id="vrBtn" disabled>Enter VR</button>
      <button id="previewBtn" disabled>Preview Stereo (Non-VR)</button>
      <div id="status">Status: Disconnected</div>
      <div class="config">
        <label>MQTT URL: <input id="mqttUrl" value="ws://3.112.216.187:9001" /></label>
        <label>Topic: <input id="topicBase" value="demo/picarx" /></label>
      </div>
    </div>
    <video id="preview" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>
    <div id="controlInfo">
      <strong>VR Controller:</strong><br>
      Left Stick: Forward/Backward<br>
      Right Stick: Left/Right<br>
      Any Trigger: Stop
    </div>

    <!-- LiveKit SDK -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/livekit-client/2.15.7/livekit-client.umd.js"></script>

    <!-- MQTT SDK -->
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

    <!-- Three.js for WebXR -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
      // ====== 設定 ======
      const wsUrl = 'wss://relay.yuru-yuru.net';
      const token = 'eyJhbGciOiJIUzI1NiJ9.eyJ2aWRlbyI6eyJyb29tSm9pbiI6dHJ1ZSwicm9vbSI6InZyLWRlbW8iLCJjYW5TdWJzY3JpYmUiOnRydWUsImNhblB1Ymxpc2giOmZhbHNlLCJjYW5QdWJsaXNoRGF0YSI6ZmFsc2V9LCJpc3MiOiJMS19BUElfS0VZIiwiZXhwIjoxNzY2MDk2NTQ1LCJuYmYiOjAsInN1YiI6InZpZXdlci0zZDh2OTMifQ.epdrv0CftHMpIvBRdSH4gs4PuARYcA9NlqQ7Bh8uyHU';
      // ==================

      const connectBtn = document.getElementById('connectBtn');
      const vrBtn = document.getElementById('vrBtn');
      const previewBtn = document.getElementById('previewBtn');
      const statusEl = document.getElementById('status');
      const preview = document.getElementById('preview');
      const canvas = document.getElementById('canvas');
      const mqttUrlEl = document.getElementById('mqttUrl');
      const topicBaseEl = document.getElementById('topicBase');

      let room = null;
      let videoElement = null;
      let renderer, scene, cameraL, cameraR, camera;
      let xrSession = null;
      let videoTexture = null;
      let previewMode = false;
      let mqttClient = null;

      // コントローラー状態
      let lastThrottle = 0;
      let lastSteer = 0;
      const DEADZONE = 0.15;
      const SEND_INTERVAL = 100; // ms
      let lastSendTime = 0;

      function setStatus(msg) {
        statusEl.innerHTML = msg;
        console.log(msg.replace(/<br>/g, ' | '));
      }

      // MQTT接続
      function connectMqtt() {
        return new Promise((resolve, reject) => {
          const url = mqttUrlEl.value.trim();
          if (!/^wss?:\/\//.test(url)) {
            reject(new Error('MQTT URL must start with ws:// or wss://'));
            return;
          }

          if (mqttClient) {
            mqttClient.end(true);
            mqttClient = null;
          }

          const timeoutId = setTimeout(() => {
            reject(new Error('MQTT connection timeout'));
          }, 10000);

          mqttClient = mqtt.connect(url, {
            keepalive: 30,
            reconnectPeriod: 2000,
          });

          mqttClient.on('connect', () => {
            clearTimeout(timeoutId);
            console.log('MQTT connected');
            resolve();
          });

          mqttClient.on('error', (e) => {
            clearTimeout(timeoutId);
            reject(new Error('MQTT error: ' + e.message));
          });

          mqttClient.on('reconnect', () => console.log('MQTT reconnecting...'));
          mqttClient.on('close', () => console.log('MQTT disconnected'));
        });
      }

      // MQTT送信
      function publishMqtt(subtopic, payload) {
        if (!mqttClient || !mqttClient.connected) {
          return;
        }
        const base = topicBaseEl.value.trim() || 'demo/picarx';
        const topic = `${base}/${subtopic}`;
        const msg = JSON.stringify(payload);
        mqttClient.publish(topic, msg, { qos: 0, retain: false });
      }

      // 走行コマンド送信
      function sendDrive(throttle, steer) {
        publishMqtt('cmd', { throttle, steer });
      }

      // LiveKit接続
      async function connectLiveKit() {
        room = new LivekitClient.Room({
          adaptiveStream: true,
          dynacast: true,
        });

        room.on(LivekitClient.RoomEvent.TrackSubscribed, (track, pub, participant) => {
          if (track.kind === 'video') {
            videoElement = track.attach();
            videoElement.style.display = 'none';
            document.body.appendChild(videoElement);

            const previewEl = track.attach();
            preview.srcObject = previewEl.srcObject;

            if (videoTexture) {
              videoTexture.image = videoElement;
            }

            vrBtn.disabled = false;
            previewBtn.disabled = false;
          }
        });

        room.on(LivekitClient.RoomEvent.Disconnected, () => {
          setStatus('Status: Disconnected');
          vrBtn.disabled = true;
          previewBtn.disabled = true;
          connectBtn.disabled = false;
        });

        await room.connect(wsUrl, token);

        // 既存の参加者のトラックを購読
        room.remoteParticipants.forEach(p => {
          p.trackPublications.forEach(pub => {
            if (pub.isSubscribed && pub.track && pub.track.kind === 'video') {
              videoElement = pub.track.attach();
              videoElement.style.display = 'none';
              document.body.appendChild(videoElement);

              const previewEl = pub.track.attach();
              preview.srcObject = previewEl.srcObject;

              vrBtn.disabled = false;
              previewBtn.disabled = false;
            }
          });
        });

        return room.name;
      }

      // 統合接続
      async function connect() {
        connectBtn.disabled = true;
        setStatus('Status: Connecting...');

        try {
          const [roomName] = await Promise.all([
            connectLiveKit(),
            connectMqtt()
          ]);
          setStatus(`Status: Connected<br>Room: ${roomName}<br>MQTT: OK`);
        } catch (e) {
          setStatus('Status: Error - ' + e.message);
          connectBtn.disabled = false;
          if (room) {
            await room.disconnect();
            room = null;
          }
          if (mqttClient) {
            mqttClient.end(true);
            mqttClient = null;
          }
        }
      }

      // Three.js + WebXR セットアップ
      function initThreeJS() {
        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        cameraL = new THREE.PerspectiveCamera(75, 0.5, 0.1, 1000);
        cameraR = new THREE.PerspectiveCamera(75, 0.5, 0.1, 1000);
      }

      // VRモード開始
      async function enterVR() {
        if (!navigator.xr) {
          alert('WebXR is not supported on this device');
          return;
        }

        const supported = await navigator.xr.isSessionSupported('immersive-vr');
        if (!supported) {
          alert('Immersive VR is not supported');
          return;
        }

        try {
          xrSession = await navigator.xr.requestSession('immersive-vr', {
            optionalFeatures: ['local-floor', 'bounded-floor']
          });

          await renderer.xr.setSession(xrSession);
          setStatus('Status: VR Mode Active<br>Use controllers to drive');

          createStereoVideoMesh();
          renderer.setAnimationLoop(renderVR);

          xrSession.addEventListener('end', () => {
            setStatus('Status: VR Mode Ended');
            renderer.setAnimationLoop(null);
            xrSession = null;
            // 停止コマンド送信
            sendDrive(0, 0);
          });

        } catch (e) {
          setStatus('Status: Failed to enter VR - ' + e.message);
        }
      }

      // ステレオビデオメッシュ作成
      function createStereoVideoMesh() {
        if (!videoElement) return;

        videoTexture = new THREE.VideoTexture(videoElement);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;

        const radius = 5;
        const geometry = new THREE.SphereGeometry(radius, 64, 32);
        geometry.scale(-1, 1, 1);

        const materialL = new THREE.ShaderMaterial({
          uniforms: { map: { value: videoTexture } },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D map;
            varying vec2 vUv;
            void main() {
              vec2 uv = vec2(vUv.x * 0.5, vUv.y);
              gl_FragColor = texture2D(map, uv);
            }
          `,
          side: THREE.BackSide
        });

        const materialR = new THREE.ShaderMaterial({
          uniforms: { map: { value: videoTexture } },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D map;
            varying vec2 vUv;
            void main() {
              vec2 uv = vec2(0.5 + vUv.x * 0.5, vUv.y);
              gl_FragColor = texture2D(map, uv);
            }
          `,
          side: THREE.BackSide
        });

        const meshL = new THREE.Mesh(geometry.clone(), materialL);
        meshL.layers.set(1);
        scene.add(meshL);

        const meshR = new THREE.Mesh(geometry.clone(), materialR);
        meshR.layers.set(2);
        scene.add(meshR);
      }

      // コントローラー入力処理
      function processControllerInput(session, frame) {
        const now = performance.now();
        if (now - lastSendTime < SEND_INTERVAL) return;

        let throttle = 0;
        let steer = 0;
        let triggerPressed = false;

        // XR入力ソースからゲームパッド取得
        for (const source of session.inputSources) {
          if (!source.gamepad) continue;

          const gp = source.gamepad;
          const axes = gp.axes;
          const buttons = gp.buttons;

          // Questコントローラー: axes[2]=X, axes[3]=Y (thumbstick)
          // 左コントローラー: 前後（throttle）
          // 右コントローラー: 左右（steer）
          if (source.handedness === 'left' && axes.length >= 4) {
            // Y軸（前後）- 上が負、下が正なので反転
            const y = -axes[3];
            if (Math.abs(y) > DEADZONE) {
              throttle = y;
            }
          }

          if (source.handedness === 'right' && axes.length >= 4) {
            // X軸（左右）
            const x = axes[2];
            if (Math.abs(x) > DEADZONE) {
              steer = x;
            }
          }

          // トリガー（インデックス0が通常トリガー）で停止
          if (buttons.length > 0 && buttons[0].pressed) {
            triggerPressed = true;
          }
        }

        // トリガーで強制停止
        if (triggerPressed) {
          throttle = 0;
          steer = 0;
        }

        // 値が変化したか、定期送信
        const changed = Math.abs(throttle - lastThrottle) > 0.05 ||
                       Math.abs(steer - lastSteer) > 0.05;

        if (changed || (throttle !== 0 || steer !== 0)) {
          sendDrive(
            Math.round(throttle * 100) / 100,
            Math.round(steer * 100) / 100
          );
          lastThrottle = throttle;
          lastSteer = steer;
          lastSendTime = now;
        }
      }

      // VRレンダリングループ
      function renderVR(timestamp, frame) {
        if (!frame) return;

        const session = renderer.xr.getSession();

        // コントローラー入力処理
        if (session && mqttClient && mqttClient.connected) {
          processControllerInput(session, frame);
        }

        const pose = frame.getViewerPose(renderer.xr.getReferenceSpace());

        if (pose) {
          const glLayer = session.renderState.baseLayer;
          const gl = renderer.getContext();

          gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);

          for (const view of pose.views) {
            const viewport = glLayer.getViewport(view);
            gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

            const camera = view.eye === 'left' ? cameraL : cameraR;
            camera.matrix.fromArray(view.transform.matrix);
            camera.projectionMatrix.fromArray(view.projectionMatrix);
            camera.matrixWorldNeedsUpdate = true;

            camera.layers.enable(view.eye === 'left' ? 1 : 2);
            camera.layers.disable(view.eye === 'left' ? 2 : 1);

            renderer.render(scene, camera);
          }
        }

        if (videoTexture) {
          videoTexture.needsUpdate = true;
        }
      }

      // 非VRプレビューモード
      function startPreview() {
        if (!videoElement) return;

        previewMode = true;
        setStatus('Status: Preview Mode (Non-VR)<br>Use arrow keys to control');
        preview.style.display = 'none';

        videoTexture = new THREE.VideoTexture(videoElement);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;

        const aspect = window.innerWidth / window.innerHeight;
        camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
        camera.position.z = 2;

        const planeGeomL = new THREE.PlaneGeometry(1, 1);
        const materialL = new THREE.ShaderMaterial({
          uniforms: { map: { value: videoTexture } },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D map;
            varying vec2 vUv;
            void main() {
              vec2 uv = vec2(vUv.x * 0.5, vUv.y);
              gl_FragColor = texture2D(map, uv);
            }
          `
        });
        const meshL = new THREE.Mesh(planeGeomL, materialL);
        meshL.position.x = -0.55;
        scene.add(meshL);

        const planeGeomR = new THREE.PlaneGeometry(1, 1);
        const materialR = new THREE.ShaderMaterial({
          uniforms: { map: { value: videoTexture } },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D map;
            varying vec2 vUv;
            void main() {
              vec2 uv = vec2(0.5 + vUv.x * 0.5, vUv.y);
              gl_FragColor = texture2D(map, uv);
            }
          `
        });
        const meshR = new THREE.Mesh(planeGeomR, materialR);
        meshR.position.x = 0.55;
        scene.add(meshR);

        function animate() {
          if (!previewMode) return;
          requestAnimationFrame(animate);
          if (videoTexture) videoTexture.needsUpdate = true;
          renderer.render(scene, camera);
        }
        animate();

        previewBtn.disabled = true;
      }

      // キーボード操作（非VR用）
      window.addEventListener('keydown', (e) => {
        if (!mqttClient || !mqttClient.connected) return;

        const speed = 0.5;
        switch (e.code) {
          case 'ArrowUp':
            sendDrive(speed, 0);
            e.preventDefault();
            break;
          case 'ArrowDown':
            sendDrive(-speed, 0);
            e.preventDefault();
            break;
          case 'ArrowLeft':
            sendDrive(speed, -1);
            e.preventDefault();
            break;
          case 'ArrowRight':
            sendDrive(speed, 1);
            e.preventDefault();
            break;
          case 'Space':
            sendDrive(0, 0);
            e.preventDefault();
            break;
        }
      });

      // イベントリスナー
      connectBtn.addEventListener('click', connect);
      vrBtn.addEventListener('click', enterVR);
      previewBtn.addEventListener('click', startPreview);

      // 初期化
      initThreeJS();

      // リサイズ対応
      window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
