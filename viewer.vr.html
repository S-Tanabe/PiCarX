<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>VR Stereo Viewer + Controller (LiveKit + WebXR + MQTT)</title>
    <style>
      * { margin: 0; padding: 0; }
      body {
        background: #000;
        color: #fff;
        font-family: system-ui, sans-serif;
        overflow: hidden;
      }
      #ui {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 100;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      button {
        padding: 15px 30px;
        font-size: 18px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        background: #4a90d9;
        color: #fff;
      }
      button:hover { background: #3a7bc8; }
      button:disabled { background: #555; cursor: not-allowed; }
      #status {
        padding: 10px;
        background: rgba(0,0,0,0.7);
        border-radius: 8px;
        font-size: 14px;
      }
      #preview {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 320px;
        background: #111;
        border: 1px solid #333;
        border-radius: 8px;
      }
      #canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
      .config {
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 8px;
        font-size: 14px;
      }
      .config input {
        background: #222;
        border: 1px solid #444;
        color: #fff;
        padding: 5px 8px;
        border-radius: 4px;
        width: 200px;
      }
      .config label {
        display: block;
        margin: 5px 0;
      }
      #controlInfo {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background: rgba(0,0,0,0.8);
        padding: 10px;
        border-radius: 8px;
        font-size: 12px;
        max-width: 300px;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <button id="connectBtn">Connect (LiveKit + MQTT)</button>
      <button id="vrBtn" disabled>Enter VR</button>
      <button id="vrStereoBtn" disabled>Enter VR (Stereo Beta)</button>
      <button id="previewBtn" disabled>Preview Stereo (Non-VR)</button>
      <div id="status">Status: Disconnected</div>
      <div class="config">
        <label>MQTT URL: <input id="mqttUrl" value="wss://relay.yuru-yuru.net/mqtt" /></label>
        <label>Topic: <input id="topicBase" value="demo/picarx" /></label>
      </div>
    </div>
    <video id="preview" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>
    <div id="controlInfo">
      <strong>VR Controller:</strong><br>
      Left Stick: Drive (Y: Forward/Back, X: Steer)<br>
      Right Stick: Camera (X: Pan, Y: Tilt)<br>
      Any Trigger: Stop
    </div>

    <!-- LiveKit SDK -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/livekit-client/2.15.7/livekit-client.umd.js"></script>

    <!-- MQTT SDK -->
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

    <!-- Three.js for WebXR -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
      // ====== 設定 ======
      const wsUrl = 'wss://relay.yuru-yuru.net';
      const token = 'eyJhbGciOiJIUzI1NiJ9.eyJ2aWRlbyI6eyJyb29tSm9pbiI6dHJ1ZSwicm9vbSI6InZyLWRlbW8iLCJjYW5TdWJzY3JpYmUiOnRydWUsImNhblB1Ymxpc2giOmZhbHNlLCJjYW5QdWJsaXNoRGF0YSI6ZmFsc2V9LCJpc3MiOiJMS19BUElfS0VZIiwiZXhwIjoxNzY5NjIwOTgyLCJuYmYiOjAsInN1YiI6InZpZXdlci1yeGU5NzkifQ.x5_H4GL7b_Q2eIm9du9WRHxUv-YP9GaH5ZPPnr2R-1o'; // 有効期限: 30日 (2026-01-29)
      // ==================

      const connectBtn = document.getElementById('connectBtn');
      const vrBtn = document.getElementById('vrBtn');
      const vrStereoBtn = document.getElementById('vrStereoBtn');
      const previewBtn = document.getElementById('previewBtn');
      const statusEl = document.getElementById('status');
      const preview = document.getElementById('preview');
      const canvas = document.getElementById('canvas');
      const mqttUrlEl = document.getElementById('mqttUrl');
      const topicBaseEl = document.getElementById('topicBase');

      let room = null;
      let videoElement = null;
      let renderer, scene, cameraL, cameraR, camera;
      let xrSession = null;
      let videoTexture = null;
      let previewMode = false;
      let mqttClient = null;
      let vrMode = false;
      let vrModeType = null; // 'legacy' or 'layers'
      let xrReferenceSpace = null;
      let xrMediaBinding = null;
      let xrQuadLayer = null;
      let xrProjectionLayer = null;
      let xrGlContext = null;
      let stereoMeshL = null;
      let stereoMeshR = null;

      // コントローラー状態
      let lastThrottle = 0;
      let lastSteer = 0;
      let currentPan = 0;   // カメラパン角度 (-90~90)
      let currentTilt = 0;  // カメラチルト角度 (-35~65)
      const DEADZONE = 0.15;
      const SEND_INTERVAL = 100; // ms
      let lastSendTime = 0;
      let lastCameraSendTime = 0;

      function setStatus(msg) {
        statusEl.innerHTML = msg;
        console.log(msg.replace(/<br>/g, ' | '));
      }

      // MQTT接続
      function connectMqtt() {
        return new Promise((resolve, reject) => {
          const url = mqttUrlEl.value.trim();
          if (!/^wss?:\/\//.test(url)) {
            reject(new Error('MQTT URL must start with ws:// or wss://'));
            return;
          }

          if (mqttClient) {
            mqttClient.end(true);
            mqttClient = null;
          }

          const timeoutId = setTimeout(() => {
            reject(new Error('MQTT connection timeout'));
          }, 10000);

          mqttClient = mqtt.connect(url, {
            keepalive: 30,
            reconnectPeriod: 2000,
          });

          mqttClient.on('connect', () => {
            clearTimeout(timeoutId);
            console.log('MQTT connected');
            resolve();
          });

          mqttClient.on('error', (e) => {
            clearTimeout(timeoutId);
            reject(new Error('MQTT error: ' + e.message));
          });

          mqttClient.on('reconnect', () => console.log('MQTT reconnecting...'));
          mqttClient.on('close', () => console.log('MQTT disconnected'));
        });
      }

      // MQTT送信
      function publishMqtt(subtopic, payload) {
        if (!mqttClient || !mqttClient.connected) {
          return;
        }
        const base = topicBaseEl.value.trim() || 'demo/picarx';
        const topic = `${base}/${subtopic}`;
        const msg = JSON.stringify(payload);
        mqttClient.publish(topic, msg, { qos: 0, retain: false });
      }

      // 走行コマンド送信
      function sendDrive(throttle, steer) {
        publishMqtt('cmd', { throttle, steer });
      }

      // カメラパン/チルト送信
      function sendCamera(pan, tilt) {
        publishMqtt('camera', { pan, tilt });
      }

      function attachVideoTrack(track) {
        const hidden = track.attach();
        hidden.style.position = 'fixed';
        hidden.style.left = '-10000px';
        hidden.style.top = '0px';
        hidden.style.width = '2px';
        hidden.style.height = '2px';
        hidden.style.opacity = '0';
        hidden.style.pointerEvents = 'none';
        hidden.playsInline = true;
        hidden.muted = true;
        document.body.appendChild(hidden);

        const previewVideo = track.attach();
        previewVideo.playsInline = true;
        previewVideo.muted = true;
        preview.srcObject = previewVideo.srcObject;

        videoElement = hidden;
        videoElement.play().catch(() => {});
        preview.play().catch(() => {});

        vrBtn.disabled = false;
        vrStereoBtn.disabled = false;
        previewBtn.disabled = false;
      }

      async function waitForVideoReady(video, timeoutMs = 6000) {
        const start = performance.now();
        while (true) {
          if (
            video.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA &&
            video.videoWidth > 0 &&
            video.videoHeight > 0
          ) {
            return true;
          }
          if (performance.now() - start > timeoutMs) {
            return false;
          }
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }

      // LiveKit接続
      async function connectLiveKit() {
        room = new LivekitClient.Room({
          adaptiveStream: true,
          dynacast: true,
        });

        room.on(LivekitClient.RoomEvent.TrackSubscribed, (track) => {
          if (track.kind === 'video') {
            attachVideoTrack(track);
          }
        });

        room.on(LivekitClient.RoomEvent.Disconnected, async () => {
          setStatus('Status: Disconnected');
          vrBtn.disabled = true;
          vrStereoBtn.disabled = true;
          previewBtn.disabled = true;
          connectBtn.disabled = false;
          vrMode = false;
          vrModeType = null;
          cleanupLayers();
          if (xrSession) {
            try {
              await xrSession.end();
            } catch (_) {}
            xrSession = null;
          }
        });

        await room.connect(wsUrl, token);

        // 既存の参加者のトラックを購読
        room.remoteParticipants.forEach(p => {
          p.trackPublications.forEach(pub => {
            if (pub.isSubscribed && pub.track && pub.track.kind === 'video') {
              attachVideoTrack(pub.track);
            }
          });
        });

        return room.name;
      }

      // 統合接続
      async function connect() {
        connectBtn.disabled = true;
        setStatus('Status: Connecting...');

        try {
          const [roomName] = await Promise.all([
            connectLiveKit(),
            connectMqtt()
          ]);
          setStatus(`Status: Connected<br>Room: ${roomName}<br>MQTT: OK`);
        } catch (e) {
          setStatus('Status: Error - ' + e.message);
          connectBtn.disabled = false;
          if (room) {
            await room.disconnect();
            room = null;
          }
          if (mqttClient) {
            mqttClient.end(true);
            mqttClient = null;
          }
        }
      }

      // Three.js + WebXR セットアップ
      function initThreeJS() {
        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        cameraL = new THREE.PerspectiveCamera(75, 0.5, 0.1, 1000);
        cameraR = new THREE.PerspectiveCamera(75, 0.5, 0.1, 1000);
      }

      async function enterVRLegacy() {
        if (!navigator.xr) {
          alert('WebXR is not supported on this device');
          return;
        }

        const supported = await navigator.xr.isSessionSupported('immersive-vr');
        if (!supported) {
          alert('Immersive VR is not supported');
          return;
        }

        try {
          xrSession = await navigator.xr.requestSession('immersive-vr', {
            optionalFeatures: ['local-floor', 'bounded-floor']
          });

          await renderer.xr.setSession(xrSession);
          xrSession.addEventListener('end', () => {
            vrMode = false;
            vrModeType = null;
            cleanupLayers();
            setStatus('Status: VR Mode Ended');
            renderer.setAnimationLoop(null);
            xrSession = null;
            sendDrive(0, 0);
          });

          vrMode = true;
          vrModeType = 'legacy';
          cleanupLayers();
          setStatus('Status: VR Mode Active<br>Use controllers to drive');

          if (!createStereoVideoMesh()) {
            await xrSession.end();
            setStatus('Status: Video not ready for VR');
            return;
          }
          renderer.setAnimationLoop(renderVR);

        } catch (e) {
          setStatus('Status: Failed to enter VR - ' + e.message);
        }
      }

      function cleanupLayers() {
        xrReferenceSpace = null;
        xrMediaBinding = null;
        xrQuadLayer = null;
        xrProjectionLayer = null;
        xrGlContext = null;
      }

      function removeStereoMeshes() {
        if (stereoMeshL) {
          scene.remove(stereoMeshL);
          stereoMeshL.geometry.dispose();
          stereoMeshL.material.dispose();
          stereoMeshL = null;
        }
        if (stereoMeshR) {
          scene.remove(stereoMeshR);
          stereoMeshR.geometry.dispose();
          stereoMeshR.material.dispose();
          stereoMeshR = null;
        }
        if (videoTexture) {
          videoTexture.dispose();
          videoTexture = null;
        }
      }

      function cleanupLayers() {
        xrReferenceSpace = null;
        xrMediaBinding = null;
        xrQuadLayer = null;
        xrProjectionLayer = null;
        xrGlContext = null;
      }

      async function enterVRStereoBeta() {
        if (!navigator.xr) {
          alert('WebXR is not supported on this device');
          return;
        }
        if (typeof XRMediaBinding === 'undefined') {
          alert('XRMediaBinding is not available in this browser');
          return;
        }
        if (!videoElement) {
          alert('Video stream not ready yet');
          return;
        }

        const supported = await navigator.xr.isSessionSupported('immersive-vr');
        if (!supported) {
          alert('Immersive VR not supported on this device');
          return;
        }

        try {
          xrSession = await navigator.xr.requestSession('immersive-vr', {
            optionalFeatures: ['local-floor', 'bounded-floor', 'layers']
          });
        } catch (e) {
          setStatus('Status: Failed to enter VR - ' + e.message);
          return;
        }

        renderer.setAnimationLoop(null);

        try {
          xrReferenceSpace = await xrSession.requestReferenceSpace('local-floor');
        } catch (e) {
          xrReferenceSpace = await xrSession.requestReferenceSpace('local');
        }

        xrMediaBinding = new XRMediaBinding(xrSession);
        await videoElement.play().catch(() => {});
        const readyForLayer = await waitForVideoReady(videoElement);
        if (!readyForLayer) {
          await xrSession.end();
          setStatus('Status: Video not ready for XR layer');
          return;
        }

        const width = videoElement.videoWidth || 3840;
        const height = videoElement.videoHeight || 1080;
        const safeWidth = width || 3840;
        const safeHeight = height || 1080;
        const eyeWidth = safeWidth / 2;
        const quadWidth = 4;
        const quadHeight = quadWidth * (safeHeight / eyeWidth);

        try {
          xrQuadLayer = xrMediaBinding.createQuadLayer(videoElement, {
            space: xrReferenceSpace,
            layout: 'stereo-left-right',
            width: quadWidth,
            height: quadHeight,
            transform: new XRRigidTransform({ z: -3, y: 1.4 })
          });
        } catch (e) {
          await xrSession.end();
          setStatus('Status: Failed to create XR layer - ' + e.message);
          return;
        }

        xrProjectionLayer = null;
        xrGlContext = null;
        if (typeof XRWebGLLayer !== 'undefined') {
          try {
            const glCanvas = document.createElement('canvas');
            const gl = glCanvas.getContext('webgl', { alpha: true, antialias: false });
            if (gl) {
              if (gl.makeXRCompatible) {
                await gl.makeXRCompatible();
              }
              xrGlContext = gl;
              xrProjectionLayer = new XRWebGLLayer(xrSession, gl);
            }
          } catch (err) {
            console.warn('Failed to create XRWebGLLayer', err);
            xrProjectionLayer = null;
            xrGlContext = null;
          }
        }

        const activeLayers = xrProjectionLayer ? [xrProjectionLayer, xrQuadLayer] : [xrQuadLayer];
        xrSession.updateRenderState({ layers: activeLayers });
        vrMode = true;
        vrModeType = 'layers';
        setStatus('Status: VR Stereo Beta Active (Layers API)');

        const onXRFrame = (time, frame) => {
          if (!xrSession || vrModeType !== 'layers') return;
          processControllerInput(xrSession);
          xrSession.requestAnimationFrame(onXRFrame);
        };
        xrSession.requestAnimationFrame(onXRFrame);

        xrSession.addEventListener('end', () => {
          vrMode = false;
          vrModeType = null;
          cleanupLayers();
          setStatus('Status: VR Mode Ended');
          xrSession = null;
          sendDrive(0, 0);
        });

      }

      // ステレオビデオメッシュ作成
      function createStereoVideoMesh() {
        if (!videoElement) return false;

        removeStereoMeshes();

        videoTexture = new THREE.VideoTexture(videoElement);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;

        const radius = 5;
        const geometry = new THREE.SphereGeometry(radius, 64, 32);
        geometry.scale(-1, 1, 1);

        const materialL = new THREE.ShaderMaterial({
          uniforms: { map: { value: videoTexture } },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D map;
            varying vec2 vUv;
            void main() {
              vec2 uv = vec2(vUv.x * 0.5, vUv.y);
              gl_FragColor = texture2D(map, uv);
            }
          `,
          side: THREE.BackSide
        });

        const materialR = new THREE.ShaderMaterial({
          uniforms: { map: { value: videoTexture } },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D map;
            varying vec2 vUv;
            void main() {
              vec2 uv = vec2(0.5 + vUv.x * 0.5, vUv.y);
              gl_FragColor = texture2D(map, uv);
            }
          `,
          side: THREE.BackSide
        });

        stereoMeshL = new THREE.Mesh(geometry.clone(), materialL);
        stereoMeshL.layers.set(1);
        scene.add(stereoMeshL);

        stereoMeshR = new THREE.Mesh(geometry.clone(), materialR);
        stereoMeshR.layers.set(2);
        scene.add(stereoMeshR);

        return true;
      }

      // コントローラー入力処理
      function processControllerInput(session) {
        if (!session) return;
        const now = performance.now();

        let throttle = 0;
        let steer = 0;
        let panDelta = 0;
        let tiltDelta = 0;
        let triggerPressed = false;

        // XR入力ソースからゲームパッド取得
        for (const source of session.inputSources) {
          if (!source.gamepad) continue;

          const gp = source.gamepad;
          const axes = gp.axes;
          const buttons = gp.buttons;

          // Questコントローラー: axes[2]=X, axes[3]=Y (thumbstick)
          // 左コントローラー: 走行操作（throttle + steer）
          if (source.handedness === 'left' && axes.length >= 4) {
            // Y軸（前後）- 上が負、下が正なので反転
            const y = -axes[3];
            if (Math.abs(y) > DEADZONE) {
              throttle = y;
            }
            // X軸（左右）- ステアリング
            const x = axes[2];
            if (Math.abs(x) > DEADZONE) {
              steer = x;
            }
          }

          // 右コントローラー: カメラ パン/チルト
          if (source.handedness === 'right' && axes.length >= 4) {
            // X軸 → パン（左右）
            const x = axes[2];
            if (Math.abs(x) > DEADZONE) {
              panDelta = x * 3;  // 感度調整
            }
            // Y軸 → チルト（上下）- 上が負なので反転
            const y = -axes[3];
            if (Math.abs(y) > DEADZONE) {
              tiltDelta = y * 2;  // 感度調整
            }
          }

          // トリガー（インデックス0が通常トリガー）で停止
          if (buttons.length > 0 && buttons[0].pressed) {
            triggerPressed = true;
          }
        }

        // トリガーで強制停止
        if (triggerPressed) {
          throttle = 0;
          steer = 0;
        }

        // 走行コマンド送信
        if (now - lastSendTime >= SEND_INTERVAL) {
          const driveChanged = Math.abs(throttle - lastThrottle) > 0.05 ||
                               Math.abs(steer - lastSteer) > 0.05;

          if (driveChanged || (throttle !== 0 || steer !== 0)) {
            sendDrive(
              Math.round(throttle * 100) / 100,
              Math.round(steer * 100) / 100
            );
            lastThrottle = throttle;
            lastSteer = steer;
            lastSendTime = now;
          }
        }

        // カメラ パン/チルト送信
        if (now - lastCameraSendTime >= SEND_INTERVAL) {
          if (Math.abs(panDelta) > 0 || Math.abs(tiltDelta) > 0) {
            // 現在値を更新（範囲制限付き）
            currentPan = Math.max(-90, Math.min(90, currentPan + panDelta));
            currentTilt = Math.max(-35, Math.min(65, currentTilt + tiltDelta));

            sendCamera(
              Math.round(currentPan),
              Math.round(currentTilt)
            );
            lastCameraSendTime = now;
          }
        }
      }

      // VRレンダリングループ
      function renderVR(timestamp, frame) {
        if (!frame) return;

        const session = renderer.xr.getSession();

        // コントローラー入力処理
        if (session && mqttClient && mqttClient.connected) {
          processControllerInput(session);
        }

        const pose = frame.getViewerPose(renderer.xr.getReferenceSpace());

        if (pose) {
          const glLayer = session.renderState.baseLayer;
          const gl = renderer.getContext();

          gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);

          for (const view of pose.views) {
            const viewport = glLayer.getViewport(view);
            gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

            const eyeCamera = view.eye === 'left' ? cameraL : cameraR;
            eyeCamera.matrix.fromArray(view.transform.matrix);
            eyeCamera.projectionMatrix.fromArray(view.projectionMatrix);
            eyeCamera.matrixWorldNeedsUpdate = true;

            eyeCamera.layers.enable(view.eye === 'left' ? 1 : 2);
            eyeCamera.layers.disable(view.eye === 'left' ? 2 : 1);

            renderer.render(scene, eyeCamera);
          }
        }

        if (videoTexture) {
          videoTexture.needsUpdate = true;
        }
      }

      // 非VRプレビューモード
      function startPreview() {
        if (!videoElement) return;

        previewMode = true;
        setStatus('Status: Preview Mode (Non-VR)<br>Use arrow keys to control');
        preview.style.display = 'none';

        videoTexture = new THREE.VideoTexture(videoElement);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;

        const aspect = window.innerWidth / window.innerHeight;
        camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
        camera.position.z = 2;

        const planeGeomL = new THREE.PlaneGeometry(1, 1);
        const materialL = new THREE.ShaderMaterial({
          uniforms: { map: { value: videoTexture } },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D map;
            varying vec2 vUv;
            void main() {
              vec2 uv = vec2(vUv.x * 0.5, vUv.y);
              gl_FragColor = texture2D(map, uv);
            }
          `
        });
        const meshL = new THREE.Mesh(planeGeomL, materialL);
        meshL.position.x = -0.55;
        scene.add(meshL);

        const planeGeomR = new THREE.PlaneGeometry(1, 1);
        const materialR = new THREE.ShaderMaterial({
          uniforms: { map: { value: videoTexture } },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D map;
            varying vec2 vUv;
            void main() {
              vec2 uv = vec2(0.5 + vUv.x * 0.5, vUv.y);
              gl_FragColor = texture2D(map, uv);
            }
          `
        });
        const meshR = new THREE.Mesh(planeGeomR, materialR);
        meshR.position.x = 0.55;
        scene.add(meshR);

        function animate() {
          if (!previewMode) return;
          requestAnimationFrame(animate);
          if (videoTexture) videoTexture.needsUpdate = true;
          renderer.render(scene, camera);
        }
        animate();

        previewBtn.disabled = true;
      }

      // キーボード操作（非VR用）
      window.addEventListener('keydown', (e) => {
        if (!mqttClient || !mqttClient.connected) return;

        const speed = 0.5;
        switch (e.code) {
          case 'ArrowUp':
            sendDrive(speed, 0);
            e.preventDefault();
            break;
          case 'ArrowDown':
            sendDrive(-speed, 0);
            e.preventDefault();
            break;
          case 'ArrowLeft':
            sendDrive(speed, -1);
            e.preventDefault();
            break;
          case 'ArrowRight':
            sendDrive(speed, 1);
            e.preventDefault();
            break;
          case 'Space':
            sendDrive(0, 0);
            e.preventDefault();
            break;
        }
      });

      // イベントリスナー
      connectBtn.addEventListener('click', connect);
      vrBtn.addEventListener('click', enterVRLegacy);
      vrStereoBtn.addEventListener('click', enterVRStereoBeta);
      previewBtn.addEventListener('click', startPreview);

      // 初期化
      initThreeJS();

      // リサイズ対応
      window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
